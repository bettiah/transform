import {
  JsonController,
  Authorized,
  Post,
  Body,
  Get,
  Put,
  Delete,
  Param,
  HttpError,
  NotFoundError,
  BadRequestError,
  CurrentUser,
  QueryParam,
  HeaderParam,
  UnauthorizedError
} from 'routing-controllers';

import * as dto from './types';
import { LoginType } from '../types';

import { rand, normalizeUser } from '../utils';
import { redisAsync, redisMulti } from '../redis';
import { signup } from '../auth';
const config = require('../../config.json');
const debug = require('debug')('server:register');

@JsonController('')
export class MatrixClientR0Register {
  /**
   * @description : This API endpoint uses the `User-Interactive Authentication API`_.
   *
   *Register for an account on this homeserver.
   *
   *There are two kinds of user account:
   *
   *- `user` accounts. These accounts may use the full API described in this specification.
   *
   *- `guest` accounts. These accounts may have limited permissions and may not be supported by all servers.
   *
   *If registration is successful, this endpoint will issue an access token
   *the client can use to authorize itself in subsequent requests.
   *
   *If the client does not supply a ``device_id``, the server must
   *auto-generate one.
   *
   *The server SHOULD register an account with a User ID based on the
   *``username`` provided, if any. Note that the grammar of Matrix User ID
   *localparts is restricted, so the server MUST either map the provided
   *``username`` onto a ``user_id`` in a logical manner, or reject
   *``username``\s which do not comply to the grammar, with
   *``M_INVALID_USERNAME``.
   *
   *Matrix clients MUST NOT assume that localpart of the registered
   *``user_id`` matches the provided ``username``.
   *
   *The returned access token must be associated with the ``device_id``
   *supplied by the client or generated by the server. The server may
   *invalidate any access token previously associated with that device. See
   *`Relationship between access tokens and devices`_.
   *
   * @parameters : [
   *  {
   *    "default": "user",
   *    "description": "The kind of account to register. Defaults to `user`.",
   *    "enum": [
   *      "guest",
   *      "user"
   *    ],
   *    "in": "query",
   *    "name": "kind",
   *    "required": false,
   *    "type": "string",
   *    "x-example": "user"
   *  },
   *  {
   *    "in": "body",
   *    "name": "body",
   *    "schema": {
   *      "properties": {
   *        "auth": {
   *          "additionalProperties": {
   *            "description": "Keys dependent on the login type",
   *            "type": "object"
   *          },
   *          "description": "Additional authentication information for the\nuser-interactive authentication API. Note that this\ninformation is *not* used to define how the registered user\nshould be authenticated, but is instead used to\nauthenticate the ``register`` call itself. It should be\nleft empty, or omitted, unless an earlier call returned an\nresponse with status code 401.",
   *          "example": {
   *            "example_credential": "verypoorsharedsecret",
   *            "session": "xxxxx",
   *            "type": "example.type.foo"
   *          },
   *          "properties": {
   *            "session": {
   *              "description": "The value of the session key given by the homeserver.",
   *              "type": "string"
   *            },
   *            "type": {
   *              "description": "The login type that the client is attempting to complete.",
   *              "type": "string"
   *            }
   *          },
   *          "required": [
   *            "type"
   *          ],
   *          "title": "Authentication Data",
   *          "type": "object"
   *        },
   *        "bind_email": {
   *          "description": "If true, the server binds the email used for authentication to\nthe Matrix ID with the ID Server.",
   *          "example": false,
   *          "type": "boolean"
   *        },
   *        "device_id": {
   *          "description": "ID of the client device. If this does not correspond to a\nknown client device, a new device will be created. The server\nwill auto-generate a device_id if this is not specified.",
   *          "example": "GHTYAJCE",
   *          "type": "string"
   *        },
   *        "initial_device_display_name": {
   *          "description": "A display name to assign to the newly-created device. Ignored\nif ``device_id`` corresponds to a known device.",
   *          "example": "Jungle Phone",
   *          "type": "string"
   *        },
   *        "password": {
   *          "description": "The desired password for the account.",
   *          "example": "ilovebananas",
   *          "type": "string"
   *        },
   *        "username": {
   *          "description": "The basis for the localpart of the desired Matrix ID. If omitted,\nthe homeserver MUST generate a Matrix ID local part.",
   *          "example": "cheeky_monkey",
   *          "type": "string"
   *        }
   *      },
   *      "type": "object"
   *    }
   *  }
   *]
   *
   * @responses : {
   *  "200": {
   *    "description": "The account has been registered.",
   *    "examples": {
   *      "application/json": {
   *        "access_token": "abc123",
   *        "device_id": "GHTYAJCE",
   *        "user_id": "@cheeky_monkey:matrix.org"
   *      }
   *    },
   *    "schema": {
   *      "properties": {
   *        "access_token": {
   *          "description": "An access token for the account.\nThis access token can then be used to authorize other requests.",
   *          "type": "string"
   *        },
   *        "device_id": {
   *          "description": "ID of the registered device. Will be the same as the\ncorresponding parameter in the request, if one was specified.",
   *          "type": "string"
   *        },
   *        "home_server": {
   *          "description": "The server_name of the homeserver on which the account has\nbeen registered.\n\n**Deprecated**. Clients should extract the server_name from\n``user_id`` (by splitting at the first colon) if they require\nit. Note also that ``homeserver`` is not spelt this way.",
   *          "type": "string"
   *        },
   *        "user_id": {
   *          "description": "The fully-qualified Matrix user ID (MXID) that has been registered.\n\nAny user ID returned by this API must conform to the grammar given in the\n`Matrix specification <https://matrix.org/docs/spec/appendices.html#user-identifiers>`_.",
   *          "type": "string"
   *        }
   *      },
   *      "type": "object"
   *    }
   *  },
   *  "400": {
   *    "description": "Part of the request was invalid. This may include one of the following error codes:\n\n* ``M_USER_IN_USE`` : The desired user ID is already taken.\n* ``M_INVALID_USERNAME`` : The desired user ID is not a valid user name.\n* ``M_EXCLUSIVE`` : The desired user ID is in the exclusive namespace\n  claimed by an application service.\n\nThese errors may be returned at any stage of the registration process,\nincluding after authentication if the requested user ID was registered\nwhilst the client was performing authentication.\n\nHomeservers MUST perform the relevant checks and return these codes before\nperforming User-Interactive Authentication, although they may also return\nthem after authentication is completed if, for example, the requested user ID\nwas registered whilst the client was performing authentication.",
   *    "examples": {
   *      "application/json": {
   *        "errcode": "M_USER_IN_USE",
   *        "error": "Desired user ID is already taken."
   *      }
   *    }
   *  },
   *  "401": {
   *    "description": "The homeserver requires additional authentication information.",
   *    "schema": {
   *      "description": "Used by servers to indicate that additional authentication information is required,",
   *      "properties": {
   *        "completed": {
   *          "description": "A list of the stages the client has completed successfully",
   *          "items": {
   *            "example": "example.type.foo",
   *            "type": "string"
   *          },
   *          "type": "array"
   *        },
   *        "flows": {
   *          "description": "A list of the login flows supported by the server for this API.",
   *          "items": {
   *            "properties": {
   *              "stages": {
   *                "description": "The login type of each of the stages required to complete this\nauthentication flow",
   *                "items": {
   *                  "example": "example.type.foo",
   *                  "type": "string"
   *                },
   *                "type": "array"
   *              }
   *            },
   *            "required": [
   *              "stages"
   *            ],
   *            "type": "object"
   *          },
   *          "title": "Flow information",
   *          "type": "array"
   *        },
   *        "params": {
   *          "additionalProperties": {
   *            "type": "object"
   *          },
   *          "description": "Contains any information that the client will need to know in order to\nuse a given type of authentication. For each login type presented,\nthat type may be present as a key in this dictionary. For example, the\npublic part of an OAuth client ID could be given here.",
   *          "example": {
   *            "example.type.baz": {
   *              "example_key": "foobar"
   *            }
   *          },
   *          "type": "object"
   *        },
   *        "session": {
   *          "description": "This is a session identifier that the client must pass back to the home\nserver, if one is provided, in subsequent attempts to authenticate in the\nsame API call.",
   *          "example": "xxxxxxyz",
   *          "type": "string"
   *        }
   *      },
   *      "required": [
   *        "flows"
   *      ],
   *      "title": "Authentication response",
   *      "type": "object"
   *    }
   *  },
   *  "429": {
   *    "description": "This request was rate-limited.",
   *    "schema": {
   *      "description": "A Matrix-level Error",
   *      "properties": {
   *        "errcode": {
   *          "description": "An error code.",
   *          "type": "string"
   *        },
   *        "error": {
   *          "description": "A human-readable error message.",
   *          "type": "string"
   *        }
   *      },
   *      "required": [
   *        "errcode"
   *      ],
   *      "type": "object"
   *    }
   *  }
   *}
   *
   * @summary : Register for an account on this homeserver.
   *
   */
  @Post('/_matrix/client/r0/register')
  async register(
    @QueryParam('kind') kind: string,
    @Body({ required: true })
    body: dto.RegisterBody
  ): Promise<
    | dto.RegisterResponse
    | dto.AuthenticationResponse
    | dto.RegisterResponse429
    | any
  > {
    if (body.auth && body.auth.session && body.auth.type === LoginType.dummy) {
      const [session, _] = await redisMulti()
        .get(body.auth.session)
        .del(body.auth.session)
        .execAsync();
      debug('session', session);
      if (!session) {
        throw new UnauthorizedError('invalid session');
      }
      // get user / pass from session
      const [user, pass] = session.split(':');
      const device_id = body.device_id || rand(); // TODO - store, check device_id
      const signedIn = await signup(normalizeUser(user), pass, device_id);
      const resp: dto.RegisterResponse = {
        access_token: signedIn.jwt,
        device_id,
        home_server: signedIn.user.home_server,
        user_id: signedIn.user.user_id
      };
      return resp;
    } else if (body.username && body.password) {
      // TODO - check if in use
      const session = rand();
      // TODO - store hash of password
      const value = `${body.username}:${body.password}`;
      // save to redis, expire soon
      await redisAsync().setAsync(session, value, 'EX', config.session_timeout);
      // send back a session id
      const resp: dto.AuthenticationResponse = {
        session,
        flows: [{ stages: [LoginType.dummy] }]
      };
      return resp;
    }
    throw new HttpError(501);
  }
}
